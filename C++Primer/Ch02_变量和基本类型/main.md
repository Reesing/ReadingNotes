# 第二章 变量和基本类型

## 2.1 基本内置类型

### 2.1.1 算术类型

- 算术类型（arithmetic type）分两类
    - 整型（integral type）
        - **字符** 和 **布尔类型**
        - 其他整形（见 [带符号类型和无符号类型](#unsigned)）
    - 浮点型

- 算术类型的尺寸（即数据所占 **byte** 数量）在不同机器上有所差别。
    - 字节（byte） = 可寻址的最小内存块
    - 字（word）= 存储的基本单元，通常由几个字节组成
    - 一个字节（byte）至少要能容纳机器基本字符符集中的字符
        - `char` 大小 = 一个机器字节（byte）
    - **1 byte = 8 bits, word = 4(or 8) bytes = 32(or 64) bits**
    - 内存中每个byte与被称为地址（address）的数字关联起来
        - 为了明确内存中某地址的含义，**必须首先知道存储在该地址的数据类型**
        - 数据类型决定了数据所占 bits 数，以及如何解释这些 bits 的内容

- 算术类型最小尺寸

    类型|最小尺寸|<center>说明</center>
    :-:|:-:|:--
    `bool`| 未定义|-
    `char`| 8位 | 应确保可以存放 **机器基本字符集** 中任意字符<br>`char` 大小 = 一个机器字节（byte）
    `wchar_t`| 16位 | 应确保可以存放 **机器最大扩展字符集** 中任意字符
    `char16_t`| 16位 |为 **Unicode字符** 集服务
    `char32_t`| 32位|为 **Unicode字符** 集服务
    `short`| 16位|-
    `int`| 16位| `int` 至少和 `short` 一样大
    `long`| 32位| `long` 至少和 `int` 一样大
    `long long`| 64位| `long long` 至少和 `long` 一样大
    `float`| 6位有效数字 | `float` = 1 word = 4 bytes = 32 bits
    `double`| 10位有效数字 | `double` = 2 words = 8 bytes = 64 bits
    `long double`|10位有效数字 |`long double` = 3(or 4) words = 12(or 16) bytes = 96(or 128) bits

- <a name="unsigned">带符号类型和无符号类型</a>
    - 其他整形
        - 带符号的 `signed`
            - 可以表示正数、负数或0
            - `int`，`short`，`long`，`long long`
        - 无符号的 `unsigned`
            - 仅能表示大于等于0的值
            - `unsigned int`（可缩写为 `unsigned`），`unsigned short`，`unsigned long`，`unsigned long long`
    - 字符型
        - `char`
            - `char` != `signed char`
        - `signed char`
        - `unsigned char`
    - 如何选择类型？
        - C++ 的设计准则之一是**尽可能地接近硬件**
        - 当明确知道不可能为负时，用 `unsigned`
        - 在算术表达式中，不要使用 `bool` 或 `char`
            - 因为随机器不同，`char` 类型有可能是 `signed`，也可能是 `unsigned`，进行运算特别容易出问题
        - 执行浮点数运算用 `double`

### 2.1.2 类型转换

- 若使用了一种类型而其实应取另一种类型时，程序会自动进行类型转换。类型所能表示的值的范围决定了转换的过程
    ```cpp
    // 以下假设 char 占 8 bits
    unsigned char c = -1; // unsigned char 取值范围为 0~255，因此c的值为255
    signed char c2 = 256; // signed char 取值范围为 -127~127, 因此 c2 的值未定义
    ```
    - 当赋给 `unsigned` 类型一个超出表示范围的值时，结果是初始值对 `unsigned` 类型表示**数值总数取模后的余数**
    - 当赋给 `signed` 类型一个起来表示范围的值时，结果是**未定义的**（undefined），程序可能继续工作，或崩溃，或生成垃圾数据

- 含有无符号类型的表达式
    - **算术表达式中既有 `unsigned` 数又有 `int` 时，`int` 值会转换为 `unsigned`**
        ```cpp
        // 假设 int 占 32 bits
        unsigned u = 10;
        int i = -42;
        std::cout << i + i << std::endl; // 输出 -84, 正常
        std::cout << u + i << std::endl; // 输出 4294967264 = (2^32-42) + 10
        ```
    
    - 若从 `unsigned` 中减去一个数时，必须确保结果非负，否则会取模
        - **会关系到循环的写法！**

    - 不要滥用 `unsigned` 和 `signed` 类型！

### 2.1.3 字面值常量（literal）

- 整型和浮点型字面值
    - 整型字面值可以写作十、八、十六进制数形式
        - 八进制以 `0` 开头
        - 十六进制以 `0x` 或 `0X` 开头
    - 浮点型字面值表现为小数或以科学计数法表示的指数
        - 指数部分用 `E` 或 `e` 标识，如 `3.141E0`，`1e3`
        - 浮点型字面值默认是 `double`

- 字符和字符串字面值
    - `char` 型字面值：由**单引号**括起来的一个字符，如 `'a'`
    - 字符串型字面值：**双引号**括起来的零个或多个字符，如 `"Hello world!"`
        - 实质上是由常量字符构成的**数组**（array）
        - 编译器在每个字符串的结尾处添加一个**空字符** `'\0'`
        - 所以，**字符串字面值的实际长度 = 其内容 + 1**
    - 若两个字符串字面值相邻且仅由**空格**、**缩进**或**换行符**分隔，则它们实际上是一个整体
        ```cpp
        // 以下两个语句等价
        std::cout << "Part 1 "
                     "Part 2" << std::endl;
        std::cout << "Part 1 " "Part 2" << std::endl;
        std::cout << "Part 1 Part 2" << std::endl;
        ``` 

- 转义序列
    - 有两类字符不能直接使用，要使用转义序列（escape sequence）
        - 不可打印（nonprintable）字符，这些字符没有可视的图符，如退格等
        - 在C++中有特殊含义的字符，如单引号、双引号、问号、反斜线等

        符号|转义序列|符号|转义序列|符号|转义序列
        :-:|:-:|:-:|:-:|:-:|:-:
        换行符|`\n`|横向制表符|`\t`|报警符|`\a`
        纵向制表符|`\v`|退格符|`\b`|双引号|`\"`
        反斜线|`\\`|问号|`\?`|单引号|`\'`
        回车符|`\r`|进纸符|`\f`
    
    - 泛化的转义序列
        - `\x` 后加一个或多个十六进制的数字，要用到 `\x`后的**所有数字**
        - `\` 后加1-3个八进制数字，只算 `\` 后的**最多三个数字**
        - 示例：
            `\0` 空字符，`\12` 换行符，`x4d` 字符 `M`

- 指定字面值的类型
    - 通过添加前缀的后缀，可以改变整形、浮点型和字符型字面值的默认类型
    - 字符和字符串字面值

        前缀|含义|类型|说明|举例
        :-:|:-:|:-:|:-:|:-:
        `u`|Unicode 16字符|`char16_t`|-|`u'a'`
        `U`|Unicode 32字符|`char32_t`|-|`U'b'`
        `L`|宽字符|`wchar_t`|-|`L'c'`
        `u8`|UTF-8|`char`|仅用于*字符串字面常量*<br>UTF-8用8位编码一个Unicode字符|`u8"hi!"`
    
    - 整型字面值
        后缀|类型|说明|举例
        :-:|:-:|:-:|:-:
        `u` / `U`|`unsigned`|-|`10ULL`：无符号整型字面值，<br>类型是 `unsigned long long`
        `l` / `L`|`long`|小写字母 `l` 与数字 `1` 太容易混淆，<br>所以*一般使用大写字母* `L`|-
        `ll` / `LL`|`long long`|-|-

    - 浮点型字面值
        后缀|类型|说明|举例
        :-:|:-:|:-:|:-:
        `f` / `F`|`float`|-|`1E-3F`：单精度浮点型字面值，类型是 `float`
        `l` / `L`|`long double`|-|`3.14L`：扩展精度浮点型字面值，<br>类型是 `long double`

    - 布尔字面值和指针字面值
        - 布尔字面值：`true`，`false`
        - 指针字面值：`nullptr`

## 2.2 变量

C++中每个变量都有其数据类型，数据类型决定着其
- 所占内存空间的大小和布局方式
- 该空间能存储的值的范围
- 变量能参与的运算

### 2.2.1 变量定义

- 变量定义的基本形式：
    - 类型说明符（type specifier）+ 由一个或多个变量名组成的列表（变量名以逗号分隔）+ 分号（结束）

- *对象* ：指一块能存储数据并具有某种类型的内存空间

- 初始值
    - 在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量
    - 在C++中，**【初始化】与【赋值】是两个完全不同的操作**
        - 初始化是创建变量时赋予其一个初始值
        - 赋值是把对象的当前值除去，以一个新值替代

- 列表初始化（list initialization）![](../figure/cpp11.png)

    - 用花括号初始化变量
        ```cpp
        // 下列4条语句等效
        int i = 0;
        int i = {0};
        int i{0};
        int i(0);
        ```
    - 若使用列表初始化，且初始值存在丢失信息的风险，则编译器将报错
        ```cpp
        long double ld = 3.14159;
        int a{ld}, b = {ld};    // 错误：转换未执行，因为丢失信息的危险
        int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值
        ```

- 默认初始化（default initialized）
    - 若定义变量时没有指定初值，则变量被默认初始化
    - 默认值到底是什么由变量类型决定
    - 定义变量的位置也会有影响
    - 定义于任何函数体外的变量被初始化为0
    - 定义在函数体内部的内置类型变量将不被初始化
    - 每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定
    - 对于要求每个对象都显式初始化的类来说，若创建类的对象时未做明确的初始化操作，将引发错误
     - **建议初始化每一个内置类型的变量**

### 2.2.2 变量声明和定义的关系

- C++支持**分离式编译**（separate compilation）机制
    - 允许将程序分割为若干个文件，每个文件可被独立编译

- C++将声明和定义区分开来
    - **声明**（declaration）使程序知道名字
        - **一个文件若想使用别外定义的名字，必须包含对此名字的声明**
    - **定义**（defination）负责创建与名字关联的实体

- 声明 v.s. 定义 
    - 变量声明规定了变量的类型和名字
    - 定义还申请存储空间，也可能会为变量赋一个初始值

- 若想声明一个变量但不定义它，应在变量名前添加关键字 `extern`，且不要显式地初始化变量
    ```cpp
    extern int i;       // 声明
    int j;              // 定义
    extern int k = 1;   // 定义
    ```

- ***变量能且只能被定义一次，但是可以被多次声明***
    - 要在多个文件中使用同一个变量，就必须将声明和定义分离
    - **变量的定义能且仅能出来在一个文件中**，**其它用到该变量的文件必须对其进行声明**，**绝对不能重复定义**

### 2.2.3 标识符

- 标识符（identifier）由*字母*、*数字*和*下划线*组成
    - 必须以字母或下划线开头
    - 长度没有限制
    - 对大小写敏感
    - 保留字段和标准库中的字段也不能被用作标识符
    - 不能以两个连续的下划线开头，也不能以下划线紧连大写字母开头
    - 定义在函数体外的标识符不能以下划线开头

- 变量命名规范
    - 要能体现实际含义
    - 变量名一般用小写字母，如 `index`
    - 自定义类名一般以大写字母开头，如 `Sales_item`
    - 若由多个单词组成，则单词间应有明显区分

### 2.2.4 名字的作用域

- 大多数作用域（scope）都以花括号分隔
- 同一名字在不同的作用域中可能指向不同的实体
- 名字的有效区域
    - 始于：名字的声明语句
    - 终于：声明语句所有的作用域末端

- 全局作用域（global scope）：一旦声明，全局作用域内的名字在整个程序的范围内都可使用
- 块作用域（block scope）

- 建议：**在第一次使用变量时再定义它**

- 嵌套的作用域
    - 内层作用域（inner scope）
    - 外层作用域（outer scope）
    - 作用域中一旦声明了某名字，
        - 则其所嵌套的所有作用域中都能访问该名字
        - 且允许在内层作用域中重新定义外层作用域
        ```cpp
        # include <iostream>
        int reused = 42; // reused 拥有全局作用域
        int main()
        {
            int unique = 0; // unique 拥有块作用域
            // 此时使用 reused 时是用的全局变量
            std::out << reused << " " << unique << std::endl; // 输出 42 0
            int reused = 0; // 新建局部变量，覆盖全局变量 reused
            // 此时使用 reused 时是用的局部变量
            std::out << reused << " " << unique << std::endl; // 输出 0 0
            // 若仍要访问全局变量，要使用 ::reused
            std::out << ::reused << " " << unique << std::endl; // 输出 42 0
            return 0;
        }
        ```
    - 若函数中有可能用到全局变量，则不宜再定义一个同名的局部变量

## 2.3 复合类型

- **声明语句 = 基本数据类型（base type） + 声明符列表（declarator）**

### 2.3.1 引用

- 引用（reference）指“左值引用”（lvalue reference）

- 引用为对象另起了一个名字
    - 通过将声明符定成 `&d` 的形式来定义引用类型
    - **只能引用对象**
        - 因为引用本身并非数据，所以不能定义引用的引用
    - **引用必须被初始化**
    ```cpp
    int ival = 1024;
    int &refVal = ival; // refVal 指向 ival
    int &refVal2;       // 错误：引用必须被初始化
    ```
    - 定义引用时，程序是把引用和其初始值**绑定**在一起，而**不是发生拷贝**
    - 可以把引用理解为初始值的另一个名字

- 引用即别名
    - ***引用不是对象***
        - 所以**不能定义引用的引用**
    - 对引用赋值时，实质上是给引用绑定的对象进行了赋值
    - 获取引用的值时，实质上是获取了引用绑定的对象的值

- 引用的定义
    - 除两种<a name="two-exception">例外</a>情况（见[常量引用](#const-ref)与[常量指针](#const-pointer)XXXX）外，
        - **所有引用的类型都要与被绑定的对象严格匹配**
        - **引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起**

### 2.3.2 指针

- 指针（pointer）是 point to 另外一种类型的复合类型

- 指针 v.s 引用
    - 同：都实现了对其他对象的间接访问
    - 异：
        - **指针本身是对象**，允许对指针赋值和拷贝，且在指针生命周期内可以先后指向几个不同的对象
        - 指针不必在定义时赋值

- 定义指针类型的声明符写法：`*d`

- 获取对象的地址
    - 取地址符：`&`
    ```cpp
    int ival = 42;
    int *p = &ival; // p 存放 ival 的地址
    ```
    - **上面语句中的 `&` 和引用类型的声明符 `&` 是不同的！**
    - 除两种例外情况（见XXXX）外，指针的类型都要和所指向的对象严格匹配
    ```cpp
    double d;
    int *pd = &d; // 错误：指针 pd 与 d 的类型不匹配
    /*
     * error: cannot convert ‘double*’ to ‘int*’ in initialization
     *     int *pd = &d;
     *                ^
    */
    ```

- 指针值
    - 指针的值（即地址）应属于以下4种状态之一：
        1. 指向一个对象；
        2. 指向紧邻对象所占空间的下一个位置；
        3. 空指针，即指针没有指向任何对象；
        4. 无效指针
    - 不允许试图访问第2、3种形式的指针，因为它们没有指向任何具体对象，后果无法预计
    - 拷贝或访问*无效指针*的值会引发错误

- 用指针访问对象
    - 若指针指向一个对象，则可以使用**解引用符**（ `*` ）来访问该对象
    - 可以对解引用的结果赋值，实质上就是给指针所指的对象赋值
    ```cpp
    int ival = 42;
    int *p = &ival;
    std::cout << *p;    // 输出 42
    *p = 0;
    std::cout << *p;    // 输出 0 
    ```
    - 解引用操作仅适用于确实指向了某个对象的有效指针
    - `&` 和 `*` 符号既能用作表达式里的**运算符**，也能作为**声明符**出现。两种情景下含义截然不同，可以完全当作不同的符号看待    

- 空指针
    - 空指针（null pointer）不指向任何对象
    - 生成方法：
        - 方法一：
        ```cpp
        int *p1 = 0;
        ```
        - 方法二：
        ```cpp
        include <cstdlib>
        int *p2 = NULL;
        ```
        - 方法三  ![](../figure/cpp11.png)
        ```cpp
        int *p3 = nullptr;
        ```

    - **建议：初始化所有指针**
        - 使用未经初始化的指针是引发运行时错误的一大原因
        - 尽可能等定义了对象之后再定义指向它的指针
        - 如果实在不清楚指针应指向何处，就初始化为 `nullptr` 或者 `0`

- 其他指针操作
    - 可以对两个类型相同的合法指针使用相等操作符（`==`）或不相等操作符（`!=`）来比较

- `void*` 指针
    - `void*` 是一种特殊的指针类型，用于存放任意对象的地址
    - 我们对该地址中到底是什么类型的对象并不了解
        ```cpp
        double d = 3.14, *pd = &d;
        void *pv = &d;  // d 可以是任意类型的对象
        pv = pd;        // pv 可以存放任意类型的指针
        ```
    - `void*` 功能有限：
        - 与别的指针比较
        - 作为函数的输入/输出
        - 赋给另个个 `void*` 指针

### 2.3.3 理解复合类型的声明
        
- **声明语句 = 基本数据类型（base type） + 声明符列表（declarator）**
    - 基本数据类型只有一个
    - 但声明符的形式却可以不同

- 可以把空格写在类型修饰符和变量名中间。但容易产生误导
    ```cpp
    int* p;
    ```

- 指向指针的指针
    - 当有多个修饰符连写在一起时，按照其逻辑关系解释即可
    - `**` 表示指向指针的指针，`***` 表示指向指针的指针的指针，以此类推
        ```cpp
        int ival = 1024;
        int *p1 = &ival;
        int **p2 = &p1;
        ```

- 指向指针的引用
    - 要理解变量的类型是什么，方法是**从右向左阅读其定义**
        ```cpp
        int i = 42;
        int *p = &i;    // p 是一个 int 型指针
        int *&r = p;    // r 是对指针 p 的引用

        r = &i;         // r <=> p，给 r 赋值 &i <=> 令 p 指向 i
        *r = 0;         // *r <=> *p，*p = 0 <=> i = 0
        ```

## 2.4 `const` 限定符

- `const` 作用
    - 希望被定义的变量的值不能被改变
    - 防止程序改变变量的值

- 因为 `const` 对象一旦创建后就不能再改变，所以 `const` **对象必须初始化**

- 初始化和 `const`
    - 与非 `const` 类型相比，`const` 类型对象能完成大部分相同操作，但也有例外
    - 主要限制是只能对 `const` 类型对象执行不改变其内容的操作
        - 初始化：用一个对象初始化另一个对象，它们是不是 `const` 都无关紧要
        ```cpp
        // 以下语句全部合法
        int i = 42;
        const int ci = i;
        int j = ci;
        ```

- 默认状态下，`const` 对象仅在文件内有效
    - 编译器将在编译过程中把用到该变量的地方都替换成应对的值
    - 若想只在一个文件中定义 `const`，同时在其他多个文件中声明并使用它，则应该不管是声明还是定义 `const` 变量都添加 `extern` 关键字。这样只用定义一次就可以
    ```cpp
    // file.cc 定义并初始化一个常量 bufSize，它可以被其他文件访问
    extern const int bufSize = fcn();
    // file.h 头文件
    extern const int bufSize;
    ```

### 2.4.1 `const` 的引用

- 对常量的引用（reference to const）
    - 对常量的引用亦不能被修改
        ```cpp
        const int ci = 1024;
        const int &r1 = ci;  // 正确
        r1 = 42;             // 错误，r1 是对常量的引用，不可修改
        int &r2 = ci;        // 错误，不允许让一个非常量引用指向一个常量对象，
                             // 因为有可能 r2 会被赋值
        ```

- 初始化和对 `const` 的引用
    - [两个例外](#two-exception)之一：<a name="const-ref">常量引用</a>
        - 在初始化常量引用时允许用**任意结果可以转化为该引用的类型的表达式**作为初始值